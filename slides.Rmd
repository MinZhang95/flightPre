---
title: "FlightScanner"
subtitle: ""
author: "Dapeng Hu, Yang Qiao, Min Zhang, Xin Zhang, Zerui Zhang"
institute: "Iowa State University"
date: "2019/05/06"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
library(flightscanner)
library(dplyr)
```

# Motivation 

<img src="image/Logo.png" style="position:absolute;top:0px;right:0px;width:15%" />

- "All flights cost money, but some are affordable!"

--

- Existing flight searching engines (e.g. [Google Flight](https://www.google.com/flights?hl=en#flt=/m/02j3w..2019-05-20*./m/02j3w.2019-05-24;c:USD;e:1;ls:1w;sd:0;t:h) is a very good flight searching engine, how could we beat products alike?).

--

- They are not perfect: distracting ads/ no map of origin & destination/ cannot search automatically.

--

- Our goal: build a flight searching R package and Shiny APP from 0, and solve the problems we noticed. 

--

- Google Flight API was deprecated on April/10/2018. Instead, we used Rapid API which enquires data from Skyscanner.

---
# Skyscanner

<img src="image/Logo.png" style="position:absolute;top:0px;right:0px;width:15%" />

[Skyscanner](https://www.skyscanner.com/) is a travel fare aggregator website and travel metasearch engine based in Scotland, owned by Ctrip, the largest travel company in China.

```{r, out.width='100%', fig.align='center', echo=F}
knitr::include_graphics('image/skyscanner.png')
```

--

[Skyscanner flight search via Rapid API (free)](https://rapidapi.com/skyscanner/api/skyscanner-flight-search)

---
class: inverse, center, middle

# Get Started

---

# Hello FlightScanner!

Install the **FlightScanner** package from [Github](https://github.com/MinZhang95/flightscanner)

```{r eval=FALSE, tidy=FALSE}
devtools::install_github("MinZhang95/flightscanner")
```

--

Main files:

- api.R

--

- database.R

--

- dataprocess.R

---

# api.R
- Set API hostname and key globally
```{r, eval = FALSE, tidy = FALSE}
SetAPI <- function(host, key) {
  options(API = list(host = host, key = key))
}
```

--
- Process of create session and poll session
![](image/session_graph.png)

---
# api.R
- Create a session with query details and get a session ID
```{r, eval=FALSE, tidy=FALSE}
CreateSession <- 
 function(origin, destination, startDate, returnDate = NULL,
          adults = 1, children = NULL, infants = NULL,
          country = "US", currency = "USD", locale = "en-US",
          cabinClass = c("economy", "premiumeconomy", "business", "first"),
          includeCarriers = NULL, excludeCarriers = NULL)
```

--
- Get back the session ID in the `location` header from the output of CreateSession
```{r, eval=FALSE, tidy=FALSE}
SessionKey <- function(x) {
  location <- headers(x)$location
  y <- strsplit(location, "/")[[1]]
  y[length(y)]
}
```
---
# api.R
Use session ID to poll results, sort results and filter results farther.
```{r, eval=FALSE, tidy=FALSE}
PollSession <- 
  function(response, sortType = c("price", "duration", "carrier",
              "outboundarrivetime", "outbounddeparttime",
              "inboundarrivetime", "inbounddeparttime"),
           sortOrder = c("asc", "desc"),
           duration = NULL, stops = NULL,
           includeCarriers = NULL,
           excludeCarriers = NULL,
           originAirports = NULL,
           destinationAirports = NULL,
           outboundDepartTime = NULL,
           outboundDepartStartTime = NULL, 
           outboundDepartEndTime = NULL,
           outboundArriveStartTime = NULL,
           outboundArriveEndTime = NULL,
           inboundDepartTime = NULL,
           inboundDepartStartTime = NULL, inboundDepartEndTime = NULL,
           inboundArriveStartTime = NULL, inboundArriveEndTime = NULL)
```

---
# Unpack.R
There are several sub-list in the content of output of PollSession, such as itineraries, legs, segments, etc. 
--
$$
\text{search result} 
\begin{cases}
  \text{itinerary_1} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} \\
          \text{segment_2} \\
          \vdots \\
          \text{segment_S}
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases} \\
  \text{itinerary_2} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} \\
          \text{segment_2} 
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases} \\
  \vdots \\
  \text{itinerary_n} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} 
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases}
\end{cases}
$$
Each sub-list has its own variables, we need to write some functions to extract each sub-list and link them together.

---
#Unpack.R
Here is a set of functions we write to extract each sub-list of the response and store it in dataframes.
- GetPrice

- GetItineraries

- GetLegs

- GetSegments

- GetCarriers

- GetAgents

- GetPlaces


---
# Unpack.R \- GetPrice
```{r, echo=FALSE, message=FALSE, warning=FALSE}
name <- load("extdata/respshow.rda")
response <- get(name)
data <- GetData(response)
head(data$price,3) %>% print(width = 120)
cat("-------------------------------------------------------")
data$price$PricingOptions[[1]] %>% print(width = 60)
```


---
# Unpack.R \- GetLegs
```{r, echo=FALSE, message=FALSE, warning=FALSE, comment=""}
head(data$legs, 3) %>% print(width = 110)
cat("-------------------------------------------------------")
data$legs$SegmentIds[[1]]
cat("-------------------------------------------------------")
data$legs$Stops[[1]]
```

---
# Unpack.R \- GetSegments
```{r, echo=FALSE, message=FALSE, warning=FALSE}
head(data$segments) %>% print(width = 120)
```

---
# Unpack.R \- GetCarriers
```{r, echo=FALSE, message=FALSE, warning=FALSE}
head(data$carriers %>% filter(Code != ""))[1:3]
```

---
# Unpack.R \- GetAgents
```{r, echo=FALSE, message=FALSE, warning=FALSE}
head(data$agents)[1:3]
```
---
# Unpack.R \- GetPlaces
```{r, echo=FALSE, message=FALSE, warning=FALSE}
head(data$places)
```
---
# dataprocess.R
This file has some functions to deal with the data. Two main functions:

--

- **GetData**: obtain some data.frames from the source.

    - **GetData.response**  
      extract data from API response (list).
      
    - **GetData.SQLiteConnection**  
      read data from SQLite database (connection).

--

- **FilterFlight**: filter flights with user-provided conditions.

---
# dataprocess.R \- GetData
```r
GetData(x, ...)
```

2 methods: 
- `response`: from API response
- `SQLiteConnection`: from SQLite database

--

Return a list of 7 tibbles, using functions in unpack.R.

- Price
- Itinerary
- Leg
- Segment
- Carrier
- Agent
- Place

---
# dataprocess.R \- FilterFlight
```r
FilterFlight(x, max_price, max_duration, max_stops, layover,
             carrier_include, carrier_exclude,
             out_departure, out_arrival, in_departure, in_arrival)
```

|parameter | description |
|:---------|:------------|
| x | A list of data.frame. (from GetData) |
| max_price | Maximum price. |
| max_duration | Maximum duration in minutes. |
| max_stops | Maximum number of stops. |
| layover | Range of layover in minutes. |
| carrier_include, carrier_exclude | Include / Exclude specified carriers. |
| out_departure, out_arrival, in_departure, in_arrival | Range of outbound / inbound departure / arrival time. |

---
# database.R
- Why **database**?
    - Scrape and save data for a period to see the price change over time.
    - Fast using SQL.

--

- Why **SQLite**?
    - Server-free, configuration-free, administration-free. Easy to use.
    - On-disk file format. Improve performance and reliability, reduce cost and complexity.
    - Very light size, compared to MySQL, Oracle, etc.
    
--

Our key functions (mainly depends on `DBI` and `RSQLite` package):

- **dbCreateDB**: Connect to / create a SQLite database file, create 7 tables.

- **dbSaveData**: Save data to SQLite database.

- **ListUnpack**, **ListPack**: Unpack / pack tibbles.

---
# database.R \- dbCreateDB
```r
dbCreateDB(conn = RSQLite::SQLite(), dbname = "flight.db")
```

Function:
1. Connect to SQLite driver

2. Create local database file "flight.db" if not exists.

3. Create 7 tables if not exist in the database.  
    - Price, Itineries, Legs, Segments, Agents, Carriers, Places.

---
# database.R \- ListUnpack, ListPack
Convert betweeen object and character string. Since SQLite doesn't support `list` as the element of `data.frame`. An example:

```{r, echo=FALSE, comment=""}
df <- tibble(a = LETTERS[1], b = list(data.frame(x = 9:10)))
df
cat("-------------------------------------------------------")
flightscanner:::ListUnpack(df, mutate = T) %>% print(width = 100)
cat("-------------------------------------------------------")
df$b[[1]]
```

---
# Automatically Key Checking

One of our package's feature is the automatcially key checking when loading the package.

If there is no file named **API_KEY.txt** in the working directory, then an interactive function **keychecking** will run.

```{r}
library(flightscanner)
```

---

# Cont.d

If the input API is not valid, then it will has message 

```{r,echo=FALSE}
cli::cat_line("Check your API key or network connection.")
```

otherwise

```{r,echo=FALSE}
cli::cat_line("Welcome to FlightScanner!")
```

The key will be stored in **API_KEY.txt** at the current directory and can be used in the future.

---

# Shiny

---
class: inverse, center, middle
# Thanks! 
![](image/thx.jpeg)
  
